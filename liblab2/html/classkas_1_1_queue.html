<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lab2final2: kas::Queue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">lab2final2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kas</b></li><li class="navelem"><a class="el" href="classkas_1_1_queue.html">Queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classkas_1_1_queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kas::Queue Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>class describe data struct - messages queue @detailed each instance of this class contains a pointer to a dynamic array of messages, index of the beginning and end of the queue, also contains max array size  
 <a href="classkas_1_1_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_queue_8h_source.html">Queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a533c0541ecf009108e8b48be9f7513ce" id="r_a533c0541ecf009108e8b48be9f7513ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a533c0541ecf009108e8b48be9f7513ce">Queue</a> ()</td></tr>
<tr class="memdesc:a533c0541ecf009108e8b48be9f7513ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor without parameters  <br /></td></tr>
<tr class="separator:a533c0541ecf009108e8b48be9f7513ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab81ef7f441d4beda8f5ac2b88914bb" id="r_a3ab81ef7f441d4beda8f5ac2b88914bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a3ab81ef7f441d4beda8f5ac2b88914bb">Queue</a> (int size, const <a class="el" href="class_mes_1_1_message.html">Message</a> arr[])</td></tr>
<tr class="memdesc:a3ab81ef7f441d4beda8f5ac2b88914bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor with queue size and array of messages  <br /></td></tr>
<tr class="separator:a3ab81ef7f441d4beda8f5ac2b88914bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad128ece89ea8088abfb95e12842ee413" id="r_ad128ece89ea8088abfb95e12842ee413"><td class="memItemLeft" align="right" valign="top"><a id="ad128ece89ea8088abfb95e12842ee413" name="ad128ece89ea8088abfb95e12842ee413"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Queue</b> ()</td></tr>
<tr class="memdesc:ad128ece89ea8088abfb95e12842ee413"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor, frees memory allocated for the queue <br /></td></tr>
<tr class="separator:ad128ece89ea8088abfb95e12842ee413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ccf7047d65676a735e187b0fc44a47" id="r_a74ccf7047d65676a735e187b0fc44a47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a74ccf7047d65676a735e187b0fc44a47">Queue</a> (const <a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;queue1)</td></tr>
<tr class="memdesc:a74ccf7047d65676a735e187b0fc44a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <br /></td></tr>
<tr class="separator:a74ccf7047d65676a735e187b0fc44a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d20d217264662e3228a9aa32485a13" id="r_a15d20d217264662e3228a9aa32485a13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a15d20d217264662e3228a9aa32485a13">Queue</a> (<a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&amp;queue1) noexcept</td></tr>
<tr class="memdesc:a15d20d217264662e3228a9aa32485a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">moving constructor  <br /></td></tr>
<tr class="separator:a15d20d217264662e3228a9aa32485a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4ef627e925236327749dfa1d8b659" id="r_a49d4ef627e925236327749dfa1d8b659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a49d4ef627e925236327749dfa1d8b659">operator=</a> (const <a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;queue1)</td></tr>
<tr class="memdesc:a49d4ef627e925236327749dfa1d8b659"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment operator @detailed copies all parameters from one queue to another  <br /></td></tr>
<tr class="separator:a49d4ef627e925236327749dfa1d8b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489ffb9890e719f6c1b95f1083f29160" id="r_a489ffb9890e719f6c1b95f1083f29160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a489ffb9890e719f6c1b95f1083f29160">operator=</a> (<a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&amp;queue1) noexcept</td></tr>
<tr class="memdesc:a489ffb9890e719f6c1b95f1083f29160"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator = : moving assignment operator @detailed swaps the fields of the calling queue and the passed one  <br /></td></tr>
<tr class="separator:a489ffb9890e719f6c1b95f1083f29160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad3ff9fbe274adac62d6dc7c1fdf2b7" id="r_a6ad3ff9fbe274adac62d6dc7c1fdf2b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mes_1_1_message.html">Message</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a6ad3ff9fbe274adac62d6dc7c1fdf2b7">operator--</a> ()</td></tr>
<tr class="memdesc:a6ad3ff9fbe274adac62d6dc7c1fdf2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator &ndash; : gets the first message from the queue @detailed if the number of messages in the queue is less than the memory allocated for it in half, then the memory is distributed, after which the first element is taken  <br /></td></tr>
<tr class="separator:a6ad3ff9fbe274adac62d6dc7c1fdf2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050d5db225aa29b00064df472811ca97" id="r_a050d5db225aa29b00064df472811ca97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a050d5db225aa29b00064df472811ca97">operator+=</a> (const <a class="el" href="class_mes_1_1_message.html">Message</a> &amp;message)</td></tr>
<tr class="memdesc:a050d5db225aa29b00064df472811ca97"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator += : puts a new message into queue @detailed if the queue is full, then redistribute the memory allocated for the queue and put a new message in it  <br /></td></tr>
<tr class="separator:a050d5db225aa29b00064df472811ca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0432b1b8ad9cd9fce2c2fc3f9759e4" id="r_a7b0432b1b8ad9cd9fce2c2fc3f9759e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkas_1_1_queue.html">Queue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a7b0432b1b8ad9cd9fce2c2fc3f9759e4">operator[]</a> (const std::string &amp;chatName)</td></tr>
<tr class="memdesc:a7b0432b1b8ad9cd9fce2c2fc3f9759e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator [] : receive all messages from the chat in the queue @detailed go through each message in the queue from its beginning and check message chat, if it matches, push to a new queue  <br /></td></tr>
<tr class="separator:a7b0432b1b8ad9cd9fce2c2fc3f9759e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b7451b754abf710b9eb3932d774745" id="r_a16b7451b754abf710b9eb3932d774745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a16b7451b754abf710b9eb3932d774745">reorganizationQueue</a> ()</td></tr>
<tr class="memdesc:a16b7451b754abf710b9eb3932d774745"><td class="mdescLeft">&#160;</td><td class="mdescRight">all adjacent messages from the same chat are merged  <br /></td></tr>
<tr class="separator:a16b7451b754abf710b9eb3932d774745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2197c4ba64d1c9806e82c318e07003" id="r_a4b2197c4ba64d1c9806e82c318e07003"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a4b2197c4ba64d1c9806e82c318e07003">orderByChat</a> ()</td></tr>
<tr class="memdesc:a4b2197c4ba64d1c9806e82c318e07003"><td class="mdescLeft">&#160;</td><td class="mdescRight">ordering the queue by chat name and sending time @detailed use sort from standard library  <br /></td></tr>
<tr class="separator:a4b2197c4ba64d1c9806e82c318e07003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d97a2b3f2edacd909c8f6bdc54e55f" id="r_a33d97a2b3f2edacd909c8f6bdc54e55f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mes_1_1_message.html">Message</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a33d97a2b3f2edacd909c8f6bdc54e55f">searchMessage</a> (const std::string &amp;word) const</td></tr>
<tr class="memdesc:a33d97a2b3f2edacd909c8f6bdc54e55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">searches for a message that contains the word @detailed go through each message in the queue from its beginning and check whether next message contains the word  <br /></td></tr>
<tr class="separator:a33d97a2b3f2edacd909c8f6bdc54e55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f606c73651c1b38862fee48f55765f4" id="r_a4f606c73651c1b38862fee48f55765f4"><td class="memItemLeft" align="right" valign="top">state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a4f606c73651c1b38862fee48f55765f4">checkState</a> () const</td></tr>
<tr class="memdesc:a4f606c73651c1b38862fee48f55765f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">check queue status, it can be empty or partially full  <br /></td></tr>
<tr class="separator:a4f606c73651c1b38862fee48f55765f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3c64c58632119401ab266454b9d3eb96" id="r_a3c64c58632119401ab266454b9d3eb96"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a3c64c58632119401ab266454b9d3eb96">outputState</a> (std::ostream &amp;c, state st)</td></tr>
<tr class="memdesc:a3c64c58632119401ab266454b9d3eb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">static method, print the queue status to the user  <br /></td></tr>
<tr class="separator:a3c64c58632119401ab266454b9d3eb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2ae64dc2d8162286f7ac6a4df92f2ef2" id="r_a2ae64dc2d8162286f7ac6a4df92f2ef2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a2ae64dc2d8162286f7ac6a4df92f2ef2">operator&lt;&lt;</a> (std::ostream &amp;c, const <a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;queue)</td></tr>
<tr class="memdesc:a2ae64dc2d8162286f7ac6a4df92f2ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator &lt;&lt; : output instance of Message @detailed output each message of the queue, if queue is empty print "queue is empty"  <br /></td></tr>
<tr class="separator:a2ae64dc2d8162286f7ac6a4df92f2ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a43d28322199420bfa32248c11479" id="r_a615a43d28322199420bfa32248c11479"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkas_1_1_queue.html#a615a43d28322199420bfa32248c11479">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;queue)</td></tr>
<tr class="memdesc:a615a43d28322199420bfa32248c11479"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator &gt;&gt; : input instance of queue @detailed enter queue size, then enter each message of queue if an input error occurred, change the stream status  <br /></td></tr>
<tr class="separator:a615a43d28322199420bfa32248c11479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>class describe data struct - messages queue @detailed each instance of this class contains a pointer to a dynamic array of messages, index of the beginning and end of the queue, also contains max array size </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a533c0541ecf009108e8b48be9f7513ce" name="a533c0541ecf009108e8b48be9f7513ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533c0541ecf009108e8b48be9f7513ce">&#9670;&#160;</a></span>Queue() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kas::Queue::Queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor without parameters </p>
<p>default </p><dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classkas_1_1_queue.html" title="class describe data struct - messages queue @detailed each instance of this class contains a pointer ...">Queue</a> with default fields: head = 0, tail = 0 capacity = 8, we also allocated memory for queue here(Queue) </dd></dl>

</div>
</div>
<a id="a3ab81ef7f441d4beda8f5ac2b88914bb" name="a3ab81ef7f441d4beda8f5ac2b88914bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab81ef7f441d4beda8f5ac2b88914bb">&#9670;&#160;</a></span>Queue() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kas::Queue::Queue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mes_1_1_message.html">Message</a>&#160;</td>
          <td class="paramname"><em>arr</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor with queue size and array of messages </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>array length(int) </td></tr>
    <tr><td class="paramname">arr</td><td>array of messages(Message*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new queue with passed size and messages(Queue) </dd></dl>

</div>
</div>
<a id="a74ccf7047d65676a735e187b0fc44a47" name="a74ccf7047d65676a735e187b0fc44a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ccf7047d65676a735e187b0fc44a47">&#9670;&#160;</a></span>Queue() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kas::Queue::Queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td>
          <td class="paramname"><em>queue1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue1</td><td>passed queue(&amp;Queue) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new queue, copy of the passed queue(Queue) </dd></dl>

</div>
</div>
<a id="a15d20d217264662e3228a9aa32485a13" name="a15d20d217264662e3228a9aa32485a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d20d217264662e3228a9aa32485a13">&#9670;&#160;</a></span>Queue() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kas::Queue::Queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>queue1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>moving constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue1</td><td>passed queue(&amp;Queue) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new queue, contains all fields in passed queue </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f606c73651c1b38862fee48f55765f4" name="a4f606c73651c1b38862fee48f55765f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f606c73651c1b38862fee48f55765f4">&#9670;&#160;</a></span>checkState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">state kas::Queue::checkState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check queue status, it can be empty or partially full </p>
<dl class="section return"><dt>Returns</dt><dd>queue state(enum state) </dd></dl>

</div>
</div>
<a id="a050d5db225aa29b00064df472811ca97" name="a050d5db225aa29b00064df472811ca97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050d5db225aa29b00064df472811ca97">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp; kas::Queue::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mes_1_1_message.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator += : puts a new message into queue @detailed if the queue is full, then redistribute the memory allocated for the queue and put a new message in it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>new message(&amp;message) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>calling queue with new message(&amp;Queue) </dd></dl>

</div>
</div>
<a id="a6ad3ff9fbe274adac62d6dc7c1fdf2b7" name="a6ad3ff9fbe274adac62d6dc7c1fdf2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad3ff9fbe274adac62d6dc7c1fdf2b7">&#9670;&#160;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mes_1_1_message.html">Message</a> &amp; kas::Queue::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator &ndash; : gets the first message from the queue @detailed if the number of messages in the queue is less than the memory allocated for it in half, then the memory is distributed, after which the first element is taken </p>
<dl class="section return"><dt>Returns</dt><dd>received message (&amp;message) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if queue is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d4ef627e925236327749dfa1d8b659" name="a49d4ef627e925236327749dfa1d8b659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d4ef627e925236327749dfa1d8b659">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp; kas::Queue::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td>
          <td class="paramname"><em>queue1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy assignment operator @detailed copies all parameters from one queue to another </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue1</td><td>passed queue(&amp;Queue) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the caller queue </dd></dl>

</div>
</div>
<a id="a489ffb9890e719f6c1b95f1083f29160" name="a489ffb9890e719f6c1b95f1083f29160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489ffb9890e719f6c1b95f1083f29160">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp; kas::Queue::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>queue1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator = : moving assignment operator @detailed swaps the fields of the calling queue and the passed one </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue1</td><td>: passed queue(&amp;&amp;queue1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the caller queue(&amp;queue) </dd></dl>

</div>
</div>
<a id="a7b0432b1b8ad9cd9fce2c2fc3f9759e4" name="a7b0432b1b8ad9cd9fce2c2fc3f9759e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0432b1b8ad9cd9fce2c2fc3f9759e4">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkas_1_1_queue.html">Queue</a> kas::Queue::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chatName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator [] : receive all messages from the chat in the queue @detailed go through each message in the queue from its beginning and check message chat, if it matches, push to a new queue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chatName</td><td>chat name(&amp;string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new queue, where each message from given chat(Queue) </dd></dl>

</div>
</div>
<a id="a4b2197c4ba64d1c9806e82c318e07003" name="a4b2197c4ba64d1c9806e82c318e07003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2197c4ba64d1c9806e82c318e07003">&#9670;&#160;</a></span>orderByChat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp; kas::Queue::orderByChat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ordering the queue by chat name and sending time @detailed use sort from standard library </p>
<dl class="section return"><dt>Returns</dt><dd>caller queue(&amp;Queue) </dd></dl>

</div>
</div>
<a id="a3c64c58632119401ab266454b9d3eb96" name="a3c64c58632119401ab266454b9d3eb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c64c58632119401ab266454b9d3eb96">&#9670;&#160;</a></span>outputState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; kas::Queue::outputState </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">state&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>static method, print the queue status to the user </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>queue status : empty/partially full(enum state) </td></tr>
    <tr><td class="paramname">c</td><td>standard output(&amp;ostream) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stream passed to the method(&amp;ostream) </dd></dl>

</div>
</div>
<a id="a16b7451b754abf710b9eb3932d774745" name="a16b7451b754abf710b9eb3932d774745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b7451b754abf710b9eb3932d774745">&#9670;&#160;</a></span>reorganizationQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp; kas::Queue::reorganizationQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>all adjacent messages from the same chat are merged </p>
<p>create a copy of queue, go through it and if we encounter messages from the same chat, we merged them and add push result to the calling queue </p><dl class="section return"><dt>Returns</dt><dd>caller queue(&amp;Queue) </dd></dl>

</div>
</div>
<a id="a33d97a2b3f2edacd909c8f6bdc54e55f" name="a33d97a2b3f2edacd909c8f6bdc54e55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d97a2b3f2edacd909c8f6bdc54e55f">&#9670;&#160;</a></span>searchMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mes_1_1_message.html">Message</a> &amp; kas::Queue::searchMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>searches for a message that contains the word @detailed go through each message in the queue from its beginning and check whether next message contains the word </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word you are looking for(&amp;string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>found message(&amp;Message) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if queue is empty and if there is no messages with that word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a2ae64dc2d8162286f7ac6a4df92f2ef2" name="a2ae64dc2d8162286f7ac6a4df92f2ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae64dc2d8162286f7ac6a4df92f2ef2">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator &lt;&lt; : output instance of Message @detailed output each message of the queue, if queue is empty print "queue is empty" </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>instance of <a class="el" href="classkas_1_1_queue.html" title="class describe data struct - messages queue @detailed each instance of this class contains a pointer ...">Queue</a> to be printed(&amp;Queue) </td></tr>
    <tr><td class="paramname">c</td><td>standard output(&amp;ostream) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stream passed to the operator(&amp;ostream) </dd></dl>

</div>
</div>
<a id="a615a43d28322199420bfa32248c11479" name="a615a43d28322199420bfa32248c11479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615a43d28322199420bfa32248c11479">&#9670;&#160;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkas_1_1_queue.html">Queue</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator &gt;&gt; : input instance of queue @detailed enter queue size, then enter each message of queue if an input error occurred, change the stream status </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>instance of <a class="el" href="classkas_1_1_queue.html" title="class describe data struct - messages queue @detailed each instance of this class contains a pointer ...">Queue</a> to be entered(&amp;Queue) </td></tr>
    <tr><td class="paramname">s</td><td>standard input (&amp;istream) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stream passed to the operator(&amp;istream) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_queue_8h_source.html">Queue.h</a></li>
<li>src/<b>Queue.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
